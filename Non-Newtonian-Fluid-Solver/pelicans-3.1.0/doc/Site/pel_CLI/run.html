<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>run - execution of a PELICANS-based application</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#arguments">ARGUMENTS</a></li>
	<li><a href="#options">OPTIONS</a></li>
	<li><a href="#examples">EXAMPLES</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>run - execution of a PELICANS-based application</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>pel run [-help|-man]</p>
<p>pel run [options...] <em>exe</em> <em>data</em> <em>resu</em></p>
<p>pel run -build_pattern <em>filename</em> -R <em>dir</em> <em>exe</em> <em>data</em> <em>resu</em></p>
<p>pel run -check_pattern <em>filename</em> <em>exe</em> <em>data</em> <em>resu</em></p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p><code>pel run</code> executes a given PELICANS-based application with a
given data file, and copy all the output messages in a given file
(or set of files in parallel mode).</p>
<p>Execution is performed in the current directory unless the option
<code>-R</code> is specified. Other options are devoted to the customization
of the execution.</p>
<p>
</p>
<hr />
<h1><a name="arguments">ARGUMENTS</a></h1>
<dl>
<dt><strong><a name="item__exe"><strong> <em>exe</em> </strong></a></strong>

<dd>
<p>Name of the executable of the PELICANS-based application to run
(this executable has usually been built with a <code>pel build</code>
command).</p>
</dd>
</li>
<dt><strong><a name="item__data"><strong> <em>data</em> </strong></a></strong>

<dd>
<p>Name of the file storing the PELICANS Hierarchical Data Structure
used as a data file for the PELICANS-based application to run.</p>
</dd>
</li>
<dt><strong><a name="item__resu"><strong> <em>resu</em> </strong></a></strong>

<dd>
<p>In sequential mode :
name of a file into which any message directed to the standard
error or to the standard output will be copied (this file will
be created or truncated).
In parallel mode : basename of the files into which any message
directed to the streams <code>PEL::out()</code> and <code>PEL::err()</code> will
be copied (these files will be created or truncated). The extension
of these files is the rank of their associated process.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="options">OPTIONS</a></h1>
<dl>
<dt><strong><a name="item__2dh_2c__2dhelp"><strong>-h, -help</strong></a></strong>

<dd>
<p>Print a brief help message and exit.</p>
</dd>
</li>
<dt><strong><a name="item__2dm_2c__2dman"><strong>-m, -man</strong></a></strong>

<dd>
<p>Print the manual page and exit.</p>
</dd>
</li>
<dt><strong><a name="item__2dnoverb"><strong>-noverb</strong></a></strong>

<dd>
<p>Deactivate the verbose option of the PELICANS-based application
(which is activated by default).</p>
</dd>
</li>
<dt><strong><a name="item__2dr_dir"><strong>-R</strong> <em>dir</em></a></strong>

<dd>
<p>Instead of running in the current directory, run recursively in
all the subdirectories of <em>dir</em> (including <em>dir</em> itself)
that contain a file of name <em>data</em>.</p>
</dd>
</li>
<dt><strong><a name="item__2dcpost"><strong>-Cpost</strong></a></strong>

<dd>
<p>Activate the evaluation of the postconditions (only effective
for sources compiled with the '<code>opt2</code>' or '<code>dbg</code>' compilation level, 
see <code>pel depend</code> ).</p>
</dd>
</li>
<dt><strong><a name="item__2dcall"><strong>-Call</strong></a></strong>

<dd>
<p>Activate the evaluation of the postconditions, invariants and
checks (only effective
for sources compiled with the '<code>opt2</code>' or '<code>dbg</code>' compilation level,
see <code>pel depend</code> ).</p>
</dd>
</li>
<dt><strong><a name="item__2dxpetsc_option"><strong>-Xpetsc</strong> <em>option</em></a></strong>

<dd>
<p>Transfer <em>option</em> to the PETSc external API.</p>
</dd>
</li>
<dt><strong><a name="item__2dx_option"><strong>-X</strong> <em>option</em></a></strong>

<dd>
<p>Transfer <em>option</em> to external APIs.</p>
</dd>
</li>
</dl>
<p>To execute a PELICANS-based application in parallel on
multiple processors, <code>pel run</code> forwards its request
to <code>mpirun</code>.</p>
<dl>
<dt><strong><a name="item__2dnp_n"><strong>-np</strong> n</a></strong>

<dd>
<p>Specify the number of processors to run on
(call <code>mpirun</code> with <strong>-np</strong> n as an option).</p>
</dd>
</li>
<dt><strong><a name="item__2dmachinefile_file"><strong>-machinefile</strong> <em>file</em></a></strong>

<dd>
<p>Take the list of possible machines to run on from
the file <em>file</em> (call <code>mpirun</code> with
<strong>-machinefile</strong> <em>file</em> as an option).</p>
</dd>
</li>
<dt><strong><a name="item__2dnolocal"><strong>-nolocal</strong></a></strong>

<dd>
<p>Call <code>mpirun</code> with <strong>-nolocal</strong> as an option.</p>
</dd>
</li>
</dl>
<p>During the final stage of the execution of a PELICANS-based application,
the object to which <code>PEL_Root::object()</code> refers is destroyed
(internally in the PELICANS framework), leading to
the destruction of all remaining instances of subclasses of <code>PEL_Object</code>
whose owner is not the <code>NULL</code> object. But it is the reponsibility of
the developer of the PELICANS-based application to call the <code>destroy()</code>
method on behalf of any objects that he may have created with <code>NULL</code>
as owner. If such is not the case, some dynamically allocated memory
might not be released when the execution terminates, and an ad-hoc
message is printed by PELICANS. The following two options
help identifying the functions in which non-destroyed objects
have been created. They should be used during two successive runs:
the first run, with the <code>-Cobject</code> option identifies a non-destroyed
object whereas the second run, with the <code>-catch</code> option locates
the function in which it had been created.</p>
<dl>
<dt><strong><a name="item__2dcobjects"><strong>-Cobjects</strong></a></strong>

<dd>
<p>Assign an identification number to each object that
has not been destroyed when the execution terminates,
and display all available information about them
(the identification number is an integer appearing
between brackets on top of each printed block).</p>
</dd>
</li>
<dt><strong><a name="item__2dcatch_nb"><strong>-catch</strong> nb</a></strong>

<dd>
<p>Display a warning message at runtime when the
object whose identification number is <code>nb</code>
is created (necessarily with the <code>NULL</code> owner).</p>
</dd>
</li>
</dl>
<p>A PELICANS-based application that can be executed by <code>pel run</code>
requires a data file (whose name is the argument <em>data</em>).
That file stores a Hierarchical Data System whose structure
is implicitely defined by the application itself (through
calls to the various member functions of <code>PEL_ModuleExplorer</code>).
PELICANS offers the possibility to ``learn'' that structure
during an execution and to record this infered knowledge
in a called ``pattern'' file (option <code>-build_pattern</code>).
This pattern file can be used in turn to check
the conformity of other data file with this structure
(option <code>-check_pattern</code>).</p>
<p>These two options are mutually exclusive. The activation of
one of them inhibits the autocheck feature (see below).</p>
<dl>
<dt><strong><a name="item__2dbuild_pattern_filename"><strong>-build_pattern</strong> <em>filename</em></a></strong>

<dd>
<p>During the run, extract the pattern of the hierarchical
data structure associated to <em>data</em>, and add it to the
file called <em>filename</em>
(which is created if it did not existed before, or extended otherwise).</p>
</dd>
</li>
<dt><strong><a name="item__2dcheck_pattern_filename"><strong>-check_pattern</strong> <em>filename</em></a></strong>

<dd>
<p>Prior to execution, check the conformity of <em>data</em>
with the pattern file <em>filename</em>.</p>
</dd>
</li>
</dl>
<p>Let us consider an execution associated to a given data file <em>data</em>. If
there is no available pattern file against which the conformity
of <em>data</em> can be checked, <code>pel run</code> offers an ``autocheck''
mode which splits the execution in two steps: a run is first performed
and a pattern is extracted from <em>data</em> (in a temporary file), then, after
completion of that run, <em>data</em> is checked against the extracted
pattern. This mode allows finding unread parts in the data
file which may be caused by typing errors.</p>
<dl>
<dt><strong><a name="item__2dautocheck"><strong>-autocheck</strong></a></strong>

<dd>
<p>Perform the run in the ``autocheck'' mode. This option is activated by default,
unless the options <strong>-build_pattern</strong> or <strong>-check_pattern</strong> are present.</p>
</dd>
</li>
<dt><strong><a name="item__2dnoautocheck"><strong>-noautocheck</strong></a></strong>

<dd>
<p>Deactivate the ``autocheck'' mode.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<dl>
<dt><strong><a name="item_pel_run__2e_2e_2fbin_2fexe_data_2epel_resu"><code>pel run  ../bin/exe data.pel resu</code></a></strong>

<dd>
<p>Run executable <em>exe</em> located in the directory <em>../bin/</em>
with the data file <em>data.pel</em>, store
all outputs in the file <em>resu</em> and perform an autocheck on <em>data.pel</em>.</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dcpost__2e_2e_2fbin_2fexe_data_2epel_res"><code>pel run -Cpost ../bin/exe data.pel resu</code></a></strong>

<dd>
<p>Same as before, with in addition the evaluation of all postconditions
of the member functions compiled with the '<code>dbg</code>' or '<code>opt2</code>'
compilation level.</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dnp_3__2dmachinefile_ms__24exe0_data_2ep"><code>pel run -np 3 -machinefile ms $EXE0 data.pel resu</code></a></strong>

<dd>
<p>Launch the executable whose name is stored in the <code>EXEO</code> environment
variable on 3 processors, with the data file <em>data.pel</em>.
The first process will be on the current machine, whereas the other ones will
be on the machines defined in the file <em>ms</em>).
Outputs directed to <code>PEL::out()</code>
and <code>PEL::err()</code> will be copied in the files <em>resu.0</em>, <em>resu.1</em>
and <em>resu.2</em> (first, second and third process).</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dnp_3__2dmachinefile_ms__2dnolocal__24ex"><code>pel run -np 3 -machinefile ms -nolocal $EXE0 data.pel resu</code></a></strong>

<dd>
<p>Same as before, but the 3 processes will be launched on the machines defined
in the file <em>ms</em>.</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dnp_3__2dmachinefile_ms__2dnolocal__2dxp"><code>pel run -np 3 -machinefile ms -nolocal -Xpetsc -trace $EXE0 data.pel resu</code></a></strong>

<dd>
<p>Same as before, with a transfer of the <em>-trace</em> option to PETSc.</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dr_test_bin_2fexe_data_2epel_resu"><code>pel run -R Test bin/exe data.pel resu</code></a></strong>

<dd>
<p>If <code>EXE</code> denotes the file <em>exe</em> located in the subdirectory
<em>bin</em> of the working directory, this command is equivalent as
executing: &nbsp;<code>pel&nbsp;run&nbsp;EXE&nbsp;data.pel&nbsp;resu</code>&nbsp;
in all the subdirectories of <em>Test</em> containing
a file <em>data.pel</em>.</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dr__2dbuild_pattern_etc_2fpattern_2epel_"><code>pel run -R -build_pattern etc/pattern.pel bin/exe data.pel resu</code></a></strong>

<dd>
<p>Same as before, with in addition the learning and storage of the
requested structure of the data files in <em>etc/pattern.pel</em>. 
No autocheck is performed.</p>
</dd>
</li>
<dt><strong><a name="item_pel_run__2dcheck_pattern__2e_2e_2fetc_2fpattern_2e"><code>pel run -check_pattern ../etc/pattern.pel ../bin/exe data.pel resu</code></a></strong>

<dd>
<p>Check the conformance of <em>data.pel</em> with <em>../etc/pattern.pel</em>
and, if successful, run subsequently <em>../bin/exe</em> with data file
<em>data.pel</em> and store all outputs in the file <em>resu</em>. No autocheck is
performed.</p>
</dd>
</li>
</dl>

</body>

</html>
