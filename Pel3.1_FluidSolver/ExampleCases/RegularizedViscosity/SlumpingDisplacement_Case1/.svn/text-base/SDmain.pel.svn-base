// Slumping Displacement
// Full channel (grid generated by PELICANS)
// Two fluids

// file includes: SDparameter.pel, ADsolver.pel, and NSsolver.pel

MODULE PEL_Application
   
   concrete_name = "FE_StepByStepProgression"
   
   //***********************************************
   //***********************************************
   // ALL parameters have dimension and are written in SI system.
   
   // Geometrical parameters
   $DS_PipeLength = 0.2  // (m)
   $DS_PipeDiameter = 0.01905  //(m)
   $DS_LeftFluidInitialLenght= $DS_PipeLength/2. //(m)
   $DS_angle= 85.
   $DS_beta = $DS_angle*pi()/180.  // horizontal slot for beta=pi/2
                      // g = Stokes * <cos(beta), -sin(beta)> see SDparameter.pel
   $DS_ExpFlowrate =7.48e-07// m^3/s 
   
   // Fluid 1 (C=0, left)
   $DS_Rho1 = 1005.01  // (kg/m^3)
   $DS_Mu1  = 0.001  // (Pa.s)  // mu1(C) = mu1*gamma^(n-1)(u) + Bn/gamma(u)
   $DS_Bn1 = 0.0     // Bn1= tau/(mu*(Ustar/D)^n)
   $DS_n1 = 1.  // PowerLaw index
  
   // Fluid 2 (C=1, right)
   $DS_Rho2= 998. // (kg/m^3)
   $DS_Mu2 = 0.001  // (Pa.s)
   $DS_Bn2 = 0.0    // Bn= tau/(mu*(Ustar/D)^n)
   $DS_n2 = 1.  // PowerLaw index

   // Time
   $DS_ExperimentalTime = 10.0  // (s)

   // Constants
   $DS_g = 9.81 // (m/s^2) // gravity (only used for Froude number)
   
   // Determine characteristic velocity
   $DS_U0 = $DS_ExpFlowrate/(pi()*$DS_PipeDiameter*$DS_PipeDiameter/4.)  // m/s
   $DS_Ub1 = ($DS_Rho1-$DS_Rho2)*$DS_g*$DS_PipeDiameter*$DS_PipeDiameter/$DS_Mu1
   $DS_Ub2 = sqrt(($DS_Rho1-$DS_Rho2)/$DS_Rho1*$DS_g*$DS_PipeDiameter)
   $DS_Ustar = max(min($DS_Ub1,$DS_Ub2),$DS_U0)
   
   // Other things
   $IS_save = 20  // number of images that should be stored for t = 0..$DS_TEND (dimensionless!)
   $DS_CourantNumber = 0.2 // set in ADsolver.pel
                           // CFL:u_x*dt/dx+u_y*dt/dy< Courant number<=0.5
   
   //***********************************************
   //**********************************************   
   // ALL parameters are non-dimensional.
   $DS_DT = 0.1  // dimensionless
   $DS_TEND = $DS_ExperimentalTime * $DS_Ustar/$DS_PipeDiameter

   $DS_Diameter = 1.0
   $DS_Length = $DS_PipeLength/$DS_PipeDiameter
   $DS_FluidInitialLength=$DS_LeftFluidInitialLenght/$DS_PipeDiameter

   // Mesh Generation. (dimensionless)
   $DS_smallestDY = 0.025  // Grid refinement in y-direction
   $DS_largestDY = 0.05  // Grid refinement in y-direction
   //NX should be of the order $DS_Length/$DS_largestDY
   $IS_NX = 100 // x=0..$DS_Length
   
   //-----------------------------------------------
   // For the BC we need 
   //----------------------------------------------
   // mean velocity Ustar (m/s)
   $DS_phi2 = 1.0
   $DS_phi1 = $DS_Rho2/$DS_Rho1
   $DS_kappa2 = 1.0
   $DS_kappa1 = $DS_Mu2/$DS_Mu1
   
   $DS_Fr = ($DS_Ustar * $DS_Ustar) / ($DS_g * $DS_PipeDiameter)  // Froude number   
   $DS_Re = $DS_Rho1*$DS_Ustar*$DS_PipeDiameter/$DS_Mu1 // Reynolds number = rho1*Ustar*D/mu1 
   $DS_St = $DS_Fr/$DS_Re // Stokes number
   
   $DS_X = component( $DV_X, 0 )
   $DS_Y = component( $DV_X, 1 )
   
   //-----------------------------------------------
   // Fluid Parameters:
   //-----------------------------------------------
   // Initial values for concentration (decides which fluid is left resp. right)
   // fluid 1 if C=0
   // fluid 2 if C=1
   $DS_InitialC = (in_range( $DS_X, vector( 0.0, $DS_FluidInitialLength ) ) ? 0.0 : 1.0 )
   // For a tilted interface use:
   // $DS_InitialC = (in_range( $DS_X, vector( 0.0, $DS_FluidInitialLength-$DS_Y*0.1 ) ) ? 0.0 : 1.0 )
   //
   // in the following we assume that fluid 1 is left and fluid 2 is right   
 
   //-----------------------------------------------
   // Init condition: U = 0.0 for t=0 inside the whole channel
   // Inflow velocity profile for t>0 and (x,y)=(0,y)
   //-----------------------------------------------
   $DS_Uscale = 1.5*$DS_U0/$DS_Ustar
   $DS_InflowU = Newtonian_VelocityProfile($DS_Y,$DS_Uscale,0.0,1.0 )
   // The factor 1.5 scales the velocity profile to flowrate=1, this fator
   // will shortly be hidden in the subroutine
   //***********************************************
   //***********************************************
   
   $BS_SteadyStateAdaptor = false // Apply steady state break critereon
   $BS_Advection = true 
   $BS_Nonlinear = false // Consider nonlinear viscosity term (set true for non-Newtonian fluids)
   
   // Field Level for time dependent fields
   $IS_CURRENT = 0 // storage of the current field
   $IS_INITIAL = 1 // storage of the previous field
   $IS_NONLIN = 2 // storage of the nonlinear contribution
   // + storage for convergence between time steps

   MODULE FE_TimeIterator
      time_initial = 0.0
      time_end = $DS_TEND
      time_step = $DS_DT 
   END MODULE FE_TimeIterator
   
   graphics_output_times = regular_vector( 0., $IS_save, $DS_TEND )
   state_saving_times = regular_vector( 0.0, $IS_save, $DS_TEND )
   
   // saving for restart
//   MODULE PEL_ObjectWriter
//      type = "last_two_cycles"
//      file_name_0 = join( getcwd(), "SDrestart_0.pel" )
//      file_name_1 = join( getcwd(), "SDrestart_1.pel" )
//      output_format = "hybrid"
//   END MODULE PEL_ObjectWriter

   if( $BS_SteadyStateAdaptor = true )
   MODULE FE_TimeIteratorAdapter
      // Stop when :
      // max( u_current-u_initial )/max( u_current, 1. ) < 1.E-5
      // max( p_current-p_initial )/max( p_current, 1. ) < 1.E-5
      concrete_name = "FE_SteadyStateAdapter"
      initial_level = $IS_NONLIN
      current_level = $IS_CURRENT 
      discrete_fields = < "velocity" "pressure" >
      minimal_error = < 1.E-5 1.E-4 >
      MODULE post_processing
         banner = true
         file_name = "convergence.txt"
      END MODULE post_processing
   END MODULE FE_TimeIteratorAdapter
   
   
/////////////////////////////////////////////////////////////////
   // PDE_DomainAndFields
/////////////////////////////////////////////////////////////////
   MODULE PDE_DomainAndFields
      verbose_level = 1
      nb_space_dimensions = 2
      type = "finite_element"
      
/////////////////////////////////////////////////////////////////
      // Define meshing
      // - no splitting if in sequential mode
      // - automatic splitting using METIS if in true parallel mode
/////////////////////////////////////////////////////////////////
      if( nb_ranks() = 1 )
      MODULE GE_Meshing
         concrete_name = "GE_BoxWithBoxes"
         mesh_polyhedron = < "GE_Segment" "GE_Rectangle" >
         vertices_coordinate_0 = regular_vector( 0., $IS_NX, $DS_Length )
         vertices_coordinate_1 =
         stretched_vector( 0., $DS_smallestDY, $DS_largestDY, $DS_Diameter/2. ) <<
         stretched_vector( $DS_Diameter/2., $DS_largestDY, $DS_smallestDY, $DS_Diameter )
      END MODULE GE_Meshing

      if( nb_ranks() = 2 )
      MODULE GE_Meshing
         concrete_name = "GE_SplitMeshing"
         MODULE splitting_strategy
            concrete_name = "GE_CoordinateSplitting"
            coordinate_splitting_formula = 
            ( $DS_X < $DS_Length/2. ? 0 : 1 )
         END MODULE splitting_strategy
         security_bandwidth = 2
         MODULE GE_Meshing
            concrete_name = "GE_BoxWithBoxes"
            mesh_polyhedron = < "GE_Segment" "GE_Rectangle" >
            vertices_coordinate_0 = regular_vector( 0., $IS_NX, $DS_Length )
            vertices_coordinate_1 =
            stretched_vector( 0., $DS_smallestDY, $DS_largestDY, $DS_Diameter/2. ) <<
            stretched_vector( $DS_Diameter/2., $DS_largestDY, $DS_smallestDY, $DS_Diameter )
         END MODULE GE_Meshing
      END MODULE GE_Meshing
      
      if( nb_ranks() > 2 )
      MODULE GE_Meshing
         concrete_name = "GE_SplitMeshing"
         MODULE splitting_strategy
            concrete_name = "EXT_METISsplitting"
         END MODULE splitting_strategy
         security_bandwidth = 2
         MODULE GE_Meshing
            concrete_name = "GE_BoxWithBoxes"
            mesh_polyhedron = < "GE_Segment" "GE_Rectangle" >
            vertices_coordinate_0 = regular_vector( 0., $IS_NX,$DS_Length )
            vertices_coordinate_1 =
            stretched_vector( 0., $DS_smallestDY, $DS_largestDY, $DS_Diameter/2. ) <<
            stretched_vector( $DS_Diameter/2., $DS_largestDY, $DS_smallestDY, $DS_Diameter )
         END MODULE GE_Meshing
      END MODULE GE_Meshing
      
      MODULE macro_colors
         no_slip = < "top" "bottom" "top_left" "top_right" "bottom_left" "bottom_right">  // Pelican generated mesh
         inflow = <"left" >
      END MODULE macro_colors
      
      MODULE interior_fields
         
         MODULE uu
            name = "velocity"
            nb_components = 2
            element_name = "PDE_2D_Q1_4nodes"
            storage_depth = 3

            MODULE DOFs_values
               type = "uniformly_defined"
               value = vector( 0.0, 0.0 )
            END MODULE DOFs_values
            MODULE DOFs_imposed_value
               MODULE Dirichlet#no_slip
                  location = "on_bounds"
                  type = "uniformly_defined"
                  color = "no_slip"
                  value = vector( 0.0, 0.0 )
               END MODULE Dirichlet#no_slip
               MODULE Dirichlet#Inflow
                  location = "on_bounds"
                  type = "uniformly_defined" 
                  color = "left"
                  value = vector( $DS_InflowU, 0.0 )
               END MODULE Dirichlet#Inflow
            END MODULE DOFs_imposed_value
         END MODULE uu
         
         MODULE pp
            name = "pressure"
            nb_components = 1
            element_name = "PDE_2D_Q0_1node"
            storage_depth = 3
            MODULE DOFs_values
               type = "uniformly_defined"
               value = < 0.0 >
            END MODULE DOFs_values
         END MODULE pp
         
         MODULE cc
            name = "CC"
            nb_components = 1
            element_name = "PDE_2D_Q0_1node"
            storage_depth = 3
            MODULE DOFs_values
               type = "uniformly_defined" 
               value = vector( $DS_InitialC )
            END MODULE DOFs_values
         END MODULE cc
         
      END MODULE interior_fields
      
      MODULE boundary_conditions
         MODULE Inflow#CCin
            field = "CC" 
            color = "inflow"
            type = "Dirichlet"
            value = 0.0 
         END MODULE Inflow#CCin
         MODULE Outflow#CC
            field = "CC" 
            color = "right"
            type = "CC_outlet"
         END MODULE Outflow#CC
         MODULE Outflow#Stress
            field = "velocity"
            color = "right"
            type = "Stress"
// pi/2           value = vector( $DS_phi1/$DS_St * $DS_Y, 0.0)
// pi             value = vector( $DS_phi1/$DS_St * $DS_X, 0.0 )
//            This value must be multiplied by phi(C)= [phi1 CC + phi2 (1-CC)]
//            which is defined as parameter (here: in SDparameter.pel bc_stress_value)
//            and needs to added in MI_NavierStokes as
//            param_bc_stress = "bc_stress_value" (here: in NSsolver.pel)            
            value = vector( 1./$DS_St * (sin($DS_beta)*$DS_Y-cos($DS_beta)*$DS_X), 0.0 )
// old_version
//            value = vector( $DS_phi1/$DS_St * (sin($DS_beta)*$DS_Y-cos($DS_beta)*$DS_X), 0.0 )
         END MODULE Outflow#Stress
      END MODULE boundary_conditions
      
      MODULE PDE_ResultSaver
         writers = < "PEL_VTKwriter" > 
         writing_mode = "text"
         files_basename = "save"
         MODULE uu
            where_to_save = "at_vertices"
            entry_name = "UU"
            field = "velocity"
         END MODULE uu
         MODULE pp
            where_to_save = "at_cell_centers"
            entry_name = "PP"
            field = "pressure"
         END MODULE pp
         MODULE cc
            where_to_save = "at_cell_centers"
            entry_name = "CC"
            field = "CC"
         END MODULE cc
      END MODULE PDE_ResultSaver
   END MODULE PDE_DomainAndFields
   
   
// -----------------------------------------------
// FE_Parameters
// -----------------------------------------------
   #include "SDparameter.pel"

// -----------------------------------------------
// One Step Iteration Stage
// -----------------------------------------------   
   MODULE FE_OneStepIteration
      concrete_name = "FE_SplitSystem" 
      MODULE list_of_FE_OneStepIteration
         #include "ADsolver.pel"
         #include "NSsolver.pel"         
         // ------------------------------------
         // FE_OneStepIteration: postprocessing
         // ------------------------------------
         MODULE FE_OneStepIteration#parameters_postprocessing
            concrete_name = "FE_ParameterSaver"
            MODULE parameters
//               MODULE param#1
//                  type = "at_cell_centers"
//                  parameter_name = "Viscosity"
//                  entry_name = "viscosity"
//               END MODULE param#1
               MODULE param#3
                  type = "at_cell_centers"
                  parameter_name = "Reynolds"
                  entry_name = "Reynolds"
               END MODULE param#3
               MODULE param#4
                  type = "at_cell_centers"
                  parameter_name = "ExtForce"
                  entry_name = "ExtForce"
               END MODULE param#4
            END MODULE parameters
         END MODULE FE_OneStepIteration#parameters_postprocessing
         
         
         // ----------------------------------------------------------
         // FE_OeStepIteration: FE_DOFsCopy (Setup of the new timestep)
         // - If another solver needs the the correct $IS_INITIAL at the new time step during
         // the execution of "do_before_inner_iteration_stage", this part has to be called 
         // after the other one step iterations.
         // ----------------------------------------------------------
         MODULE FE_OneStepIteration#DOF_copy
            concrete_name = "FE_DOFsCopy"
            MODULE uu#1
               field = "velocity"
               source = $IS_INITIAL
               target = $IS_NONLIN
            END MODULE uu#1
            MODULE uu#2
               field = "velocity"
               source = $IS_CURRENT
               target = $IS_INITIAL
            END MODULE uu#2
            MODULE pp#1
               field = "pressure"
               source = $IS_INITIAL
               target = $IS_NONLIN
            END MODULE pp#1
            MODULE pp#2
               field = "pressure"
               source = $IS_CURRENT
               target = $IS_INITIAL
            END MODULE pp#2
         END MODULE FE_OneStepIteration#DOF_copy
         
      END MODULE list_of_FE_OneStepIteration
   END MODULE FE_OneStepIteration

END MODULE PEL_Application

