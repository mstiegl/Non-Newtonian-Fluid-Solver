<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html>
<head>
  <title>GE_Mpolyhedron</title>
  <link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
</head>
<script>
  function asd()
  {
    parent.document.title="GE_Mpolyhedron_PELICANS 17_03_2010 ";
  }
</script> 

<body onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<div id=navbar>
  <a name="navbar_top_firstrow"><!-- --></a>
  <div id=navbarapp>PELICANS 17_03_2010</div>
  <div id=navbarmenu>
    <a href="GEpack-tree.html"><span>Tree</span></a>
    <span class=selected>Class</span>
    <div id=navbarsub>
      <a href="index.html" target="_top">FRAMES :</a>
      <a href="GEpack-tree.html" target="_top">: NO FRAMES</a>
    </div>
  </div>
</div>
<!-- ========== END OF NAVBAR ========== -->

<br />
<div class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></div>
<br />


<!-- ====== START OF CLASS DATA ======== -->
<div id=classtitle>
  <span class=classpath>Geometry / Polyhedron / </span><br />
  <span class=classname>Class  GE_Mpolyhedron</span>
</div>

<br />

<div id=hierarchy>
<ul class=rootclass><li><a href="PEL_Object.html#" target="classFrame">PEL_Object</a></li>
  <ul class=self><li>GE_Mpolyhedron</li>
</ul>
</div>

<!-- ========== DERIVED CLASSES ========== -->
<dl><dt><b>Direct Known Derived Classes:</b>
<dd><a href="GE_Cuboid.html#" target="classFrame">GE_Cuboid</a>, <a href="GE_Hexahedron.html#" target="classFrame">GE_Hexahedron</a>, <a href="GE_Mpoint.html#" target="classFrame">GE_Mpoint</a>, <a href="GE_Quadrilateral.html#" target="classFrame">GE_Quadrilateral</a>, <a href="GE_Rectangle.html#" target="classFrame">GE_Rectangle</a>, <a href="GE_Segment.html#" target="classFrame">GE_Segment</a>, <a href="GE_Tetrahedron.html#" target="classFrame">GE_Tetrahedron</a>, <a href="GE_Trapezoid.html#" target="classFrame">GE_Trapezoid</a>, <a href="GE_Triangle.html#" target="classFrame">GE_Triangle</a></dd>
</dl>
<hr />
<pre>

Meshes geometrical representation.

A GE_Mpolyhedron is a polyhedron i.e. a convex bounded intersection of half
spaces.

In addition to the polyhedron definition, its implies the definition
of an invertible mapping to a unique reference polyhedron that
belongs to an affine subspace of the canonical space E(n).

</pre>
<hr />
<a name="method_summary"></a>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Instance delivery and initialization</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#create" target="classFrame">static GE_Mpolyhedron* create( std::string const& a_name, GE_SetOfPoints* a_set_of_vertices, size_t_vector const& a_vertices_index_table )</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#create_" target="classFrame">static GE_Mpolyhedron* create( PEL_Object* a_owner, std::string const& a_name, PEL_Vector const* vertices )</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#update" target="classFrame">virtual void update( void )</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#check_consistency" target="classFrame">static bool check_consistency( void )</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#unset_check_consistency" target="classFrame">static void unset_check_consistency( void )</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#set_check_consistency" target="classFrame">static void set_check_consistency( void )</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Comparison</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#is_equal" target="classFrame">virtual bool is_equal( PEL_Object const* other ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#three_way_comparison" target="classFrame">virtual int three_way_comparison( PEL_Object const* other ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#hash_code" target="classFrame">virtual size_t hash_code( void ) const</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Status</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#name" target="classFrame">virtual std::string const& name( void ) const = 0</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Modification</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#reorder_vertices_according_to" target="classFrame">void reorder_vertices_according_to( GE_Mpolyhedron const* other )</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Geometrical characteristics</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">size_t nb_space_dimensions( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#dimension" target="classFrame">size_t dimension( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">size_t nb_vertices( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#nb_faces" target="classFrame">size_t nb_faces( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#vertex" target="classFrame">GE_Point const* vertex( size_t i ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#measure" target="classFrame">virtual double measure( void ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#inter_vertices_maximum_distance" target="classFrame">double inter_vertices_maximum_distance( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#inter_vertices_maximum_distance_" target="classFrame">double inter_vertices_maximum_distance( size_t dir ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#equivalent_ball_diameter" target="classFrame">double equivalent_ball_diameter( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#reference_distance" target="classFrame">double reference_distance( GE_Point const* pt1, GE_Point const* pt2 ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#center" target="classFrame">GE_Point const* center( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#finite_volume_center" target="classFrame">virtual GE_Point const* finite_volume_center( void ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#contains" target="classFrame">virtual bool contains( GE_Point const* pt ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#unit_normal" target="classFrame">virtual GE_Vector const* unit_normal( void ) const</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Reference polyhedron</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">static GE_ReferencePolyhedron const* reference_polyhedron( std::string const& a_name )</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#reference_polyhedron_" target="classFrame">virtual GE_ReferencePolyhedron const* reference_polyhedron( void ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#apply_mapping" target="classFrame">virtual void apply_mapping( GE_Point const* pt_ref, GE_Point* pt ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#apply_inverse_mapping" target="classFrame">virtual void apply_inverse_mapping( GE_Point const* pt, GE_Point* pt_ref ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#build_mapping_derivative" target="classFrame">virtual void build_mapping_derivative( GE_Point const* pt_ref, GE_Matrix* jac ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#build_tr_mapping_derivative" target="classFrame">virtual void build_tr_mapping_derivative( GE_Point const* pt_ref, GE_Matrix* tjac ) const = 0</a></td></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#build_mapping_hessian" target="classFrame">virtual void build_mapping_hessian( GE_Point const* pt_ref, doubleArray3D* hessian, bool& nonzero_hessian ) const</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Input - Output</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_Mpolyhedron.html#print" target="classFrame">virtual void print( std::ostream& os, size_t indent_width ) const</a></td></tr>
</table>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="create"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static <a href="GE_Mpolyhedron.html#" target="classFrame">GE_Mpolyhedron</a>* create(</code></td><td><code>std::string const& <span class="uid1">a_name</span>,</tr>
  <tr><td /><td><code> <a href="GE_SetOfPoints.html#" target="classFrame">GE_SetOfPoints</a>* <span class="uid1">a_set_of_vertices</span>,</tr>
  <tr><td /><td><code> <a href="size_t_vector.html#" target="classFrame">size_t_vector</a> const& <span class="uid1">a_vertices_index_table</span> ) </code></td></tr>
</table>
<pre>Create and return an instance.
The vertices are given by the table of connectivities
<span class="uid1">a_vertices_index_table</span> and the set of points <span class="uid1">a_set_of_vertices</span>.</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code>!a_name.empty()</code></li>
    <li><code><span class="uid1"><span class="uid1">a_set_of_vertices</span></span> != 0</code></li>
    <li><code>a_vertices_index_table.size() == <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )-><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>()</code></li>
    <li><code>FORALL( i = 0, i < a_vertices_index_table.size(), ++i )<br />
&nbsp;<span class="uid1"><span class="uid1">a_vertices_index_table</span></span>( i ) < <span class="uid1"><span class="uid1">a_set_of_vertices</span></span>->nb_points()</code></li>
    <li><code><span class="uid1"><span class="uid1">a_set_of_vertices</span></span>-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>() >= <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result-><a href="PEL_Object.html#owner" target="classFrame">owner</a>() == <span class="uid1"><span class="uid1">a_set_of_vertices</span></span></code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#name" target="classFrame">name</a>() == <span class="uid1"><span class="uid1">a_name</span></span></code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>() == <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )</code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>() == <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>() == <span class="uid1"><span class="uid1">a_set_of_vertices</span></span>-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>() == a_vertices_index_table.size()</code></li>
    <li><code>FORALL( i = 0, i < result-><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>(), ++i )<br />
&nbsp;result-><a href="GE_Mpolyhedron.html#vertex" target="classFrame">vertex</a>( i ) == <span class="uid1"><span class="uid1">a_set_of_vertices</span></span>->point( <span class="uid1"><span class="uid1">a_vertices_index_table</span></span>( i ) )</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="create_"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static <a href="GE_Mpolyhedron.html#" target="classFrame">GE_Mpolyhedron</a>* create(</code></td><td><code><a href="PEL_Object.html#PEL_Object" target="classFrame">PEL_Object*</a> <span class="uid1">a_owner</span>,</tr>
  <tr><td /><td><code> std::string const& <span class="uid1">a_name</span>,</tr>
  <tr><td /><td><code> <a href="PEL_Vector.html#" target="classFrame">PEL_Vector</a> const* <span class="uid1">vertices</span> ) </code></td></tr>
</table>
<pre>Create and return an instance.
The vertices are given in the vector <span class="uid1">vertices</span>.</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code>!a_name.empty()</code></li>
    <li><code><span class="uid1"><span class="uid1">vertices</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">vertices</span></span>->count() == <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )-><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>()</code></li>
    <li><code>FORALL( i = 0, i < <span class="uid1"><span class="uid1">vertices</span></span>->count(), ++i )<br />
&nbsp;dynamic_cast< <a href="GE_Point.html#" target="classFrame">GE_Point</a> const* >(<span class="uid1"><span class="uid1">vertices</span></span>->at( i )) != 0</code></li>
    <li><code>FORALL( i = 1, i < <span class="uid1"><span class="uid1">vertices</span></span>->count(), ++i )<br />
&nbsp;static_cast< <a href="GE_Point.html#" target="classFrame">GE_Point</a> const* >(<span class="uid1"><span class="uid1">vertices</span></span>->at( 0 ))->nb_coordinates() == static_cast< <a href="GE_Point.html#" target="classFrame">GE_Point</a> const* >(<span class="uid1"><span class="uid1">vertices</span></span>->at( i ))->nb_coordinates()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result-><a href="PEL_Object.html#owner" target="classFrame">owner</a>() == <span class="uid1"><span class="uid1">a_owner</span></span></code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#name" target="classFrame">name</a>() == <span class="uid1"><span class="uid1">a_name</span></span></code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>() == <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )</code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>() == <a href="GE_Mpolyhedron.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>( <span class="uid1"><span class="uid1">a_name</span></span> )-><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code>result-><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>() == <span class="uid1"><span class="uid1">vertices</span></span>->count()</code></li>
    <li><code>FORALL( i = 0, i < result-><a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>(), ++i )<br />
&nbsp;result-><a href="GE_Mpolyhedron.html#vertex" target="classFrame">vertex</a>( i ) == static_cast< <a href="GE_Point.html#" target="classFrame">GE_Point</a> const* >(<span class="uid1"><span class="uid1">vertices</span></span>->at( i ))</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="update"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void update(</code></td><td><code>void ) </code></td></tr>
</table>
<pre>Perform updating to maintain consistency between <span class="uid1">self</span> and a
set of related objects (observer pattern).

Update the specific attributes of <span class="uid1">self</span> in case of moving of its
vertices.</pre>
<br />
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="check_consistency"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static bool check_consistency(</code></td><td><code>void ) </code></td></tr>
</table>
<br />
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="unset_check_consistency"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static void unset_check_consistency(</code></td><td><code>void ) </code></td></tr>
</table>
<br />
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>!<a href="GE_Mpolyhedron.html#check_consistency" target="classFrame">check_consistency</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="set_check_consistency"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static void set_check_consistency(</code></td><td><code>void ) </code></td></tr>
</table>
<br />
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code><a href="GE_Mpolyhedron.html#check_consistency" target="classFrame">check_consistency</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="is_equal"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual bool is_equal(</code></td><td><code><a href="PEL_Object.html#PEL_Object" target="classFrame">PEL_Object const*</a> <span class="uid1">other</span> ) const</code></td></tr>
</table>
<pre>Is <span class="uid1">other</span> equal to <span class="uid1">self</span> ?

</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><a href="PEL_Object.html#comparable" target="classFrame">comparable</a>( <span class="uid1"><span class="uid1">other</span></span> )</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="three_way_comparison"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual int three_way_comparison(</code></td><td><code><a href="PEL_Object.html#PEL_Object" target="classFrame">PEL_Object const*</a> <span class="uid1">other</span> ) const</code></td></tr>
</table>
<pre>if <span class="uid1">self</span> equal to <span class="uid1">other</span>, O ; if smaller, <0 ; if greater, >0

</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><a href="PEL_Object.html#comparable" target="classFrame">comparable</a>( <span class="uid1"><span class="uid1">other</span></span> )</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result == 0 &lt;==&gt; <a href="GE_Mpolyhedron.html#is_equal" target="classFrame">is_equal</a>( <span class="uid1"><span class="uid1">other</span></span> )</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="hash_code"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual size_t hash_code(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>hash code value

</pre>
<br />
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="name"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual std::string const& name(</code></td><td><code>void ) const = 0</code></td></tr>
</table>
<pre>characteristic name of <span class="uid1">self</span></pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="reorder_vertices_according_to"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>void reorder_vertices_according_to(</code></td><td><code><a href="GE_Mpolyhedron.html#GE_Mpolyhedron" target="classFrame">GE_Mpolyhedron const*</a> <span class="uid1">other</span> ) </code></td></tr>
</table>
<pre>Assuming that each vertex of <span class="uid1">self</span> coincides with the vertex of
<span class="uid1">other</span> (a fatal error is raised if not), modifie the index of
the vertices of <span class="uid1">self</span> so that for all i, the i-th vertex of <span class="uid1">self</span>
coincides with the i-th vertex of <span class="uid1">other</span>.</pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>FORALL( i = 0, i < <a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>(), ++i )<br />
&nbsp;<a href="GE_Mpolyhedron.html#vertex" target="classFrame">vertex</a>( i )->distance( <span class="uid1"><span class="uid1">other</span></span>-><a href="GE_Mpolyhedron.html#vertex" target="classFrame">vertex</a>( i ) ) < 1.e-8</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="nb_space_dimensions"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>size_t nb_space_dimensions(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>dimension of the space <span class="uid1">self</span> is belongs to</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="dimension"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>size_t dimension(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>dimension of the subspace the reference polyhedron belongs to</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="nb_vertices"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>size_t nb_vertices(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>number of vertices</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="nb_faces"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>size_t nb_faces(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>number of facets</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="vertex"></a>
<div class=method>
<table class=prototype>
  <tr><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* vertex(</code></td><td><code>size_t <span class="uid1">i</span> ) const</code></td></tr>
</table>
<pre><span class="uid1">i</span>-th vertex</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">i</span></span> < <a href="GE_Mpolyhedron.html#nb_vertices" target="classFrame">nb_vertices</a>()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="measure"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual double measure(</code></td><td><code>void ) const = 0</code></td></tr>
</table>
<pre>measure of <span class="uid1">self</span> : its length if <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a> is 1 ;
its area if <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a> is 2 ; its volume if <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a> is 3</pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result >= 0.</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="inter_vertices_maximum_distance"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>double inter_vertices_maximum_distance(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>maximal distance between two vertices of <span class="uid1">self</span></pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="inter_vertices_maximum_distance_"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>double inter_vertices_maximum_distance(</code></td><td><code>size_t <span class="uid1">dir</span> ) const</code></td></tr>
</table>
<pre>maximal distance between two vertices of <span class="uid1">self</span> in the direction <span class="uid1">dir</span></pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">dir</span></span> < <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="equivalent_ball_diameter"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>double equivalent_ball_diameter(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>diameter of a ball which measure is the same than <span class="uid1">self</span> ones</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="reference_distance"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>double reference_distance(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt1</span>,</tr>
  <tr><td /><td><code> <a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt2</span> ) const</code></td></tr>
</table>
<pre>distance between <span class="uid1">pt1</span> and <span class="uid1">pt2</span> in <span class="uid1">self</span> characteristic length</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt1</span></span> != 0 && <span class="uid1"><span class="uid1">pt1</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">pt2</span></span> != 0 && <span class="uid1"><span class="uid1">pt2</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="center"></a>
<div class=method>
<table class=prototype>
  <tr><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* center(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>geometrical center</pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result-><a href="PEL_Object.html#owner" target="classFrame">owner</a>() == this</code></li>
    <li><code>result->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="finite_volume_center"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual <a href="GE_Point.html#" target="classFrame">GE_Point</a> const* finite_volume_center(</code></td><td><code>void ) const = 0</code></td></tr>
</table>
<pre>if it exists, geometrical point attached to <span class="uid1">self</span> that is used in
finite volume discretizations, 0 otherwise
REMARK: the set of all cells equipped with their finite
volume centers must be admissible, meaning at least that the line
connecting the finite volume centers of two adjacent cells is
perpendicular to the adjacency face)</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result == 0 || result->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="contains"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual bool contains(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt</span> ) const = 0</code></td></tr>
</table>
<pre>Is <span class="uid1">pt</span> located in <span class="uid1">self</span> ?</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt</span></span> != 0 && <span class="uid1"><span class="uid1">pt</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="unit_normal"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual <a href="GE_Vector.html#" target="classFrame">GE_Vector</a> const* unit_normal(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>an unit normal of <span class="uid1">self</span>
IMPLEMENTATION: a fatal error is raised, which means that the concrete
subclass did not implement this member function</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>() - 1</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result->nb_components() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
    <li><code><a href="PEL.html#equal" target="classFrame">PEL::equal</a>( result->norm(), 1. )</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="reference_polyhedron"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static <a href="GE_ReferencePolyhedron.html#" target="classFrame">GE_ReferencePolyhedron</a> const* reference_polyhedron(</code></td><td><code>std::string const& <span class="uid1">a_name</span> ) </code></td></tr>
</table>
<pre>reference polyhedron linked to the polyhedrons of name <span class="uid1">a_name</span>
(fatal error raised if none)</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code>!a_name.empty()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="reference_polyhedron_"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual <a href="GE_ReferencePolyhedron.html#" target="classFrame">GE_ReferencePolyhedron</a> const* reference_polyhedron(</code></td><td><code>void ) const = 0</code></td></tr>
</table>
<pre>reference polyhedron of <span class="uid1">self</span></pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="apply_mapping"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void apply_mapping(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt_ref</span>,</tr>
  <tr><td /><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a>* <span class="uid1">pt</span> ) const = 0</code></td></tr>
</table>
<pre>Projection from the reference polyhedron to <span class="uid1">self</span> (mapping).</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">pt</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="apply_inverse_mapping"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void apply_inverse_mapping(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt</span>,</tr>
  <tr><td /><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a>* <span class="uid1">pt_ref</span> ) const = 0</code></td></tr>
</table>
<pre>Projection from <span class="uid1">self</span> to its reference polyhedron (inverse mapping).</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="build_mapping_derivative"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void build_mapping_derivative(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt_ref</span>,</tr>
  <tr><td /><td><code> GE_Matrix* <span class="uid1">jac</span> ) const = 0</code></td></tr>
</table>
<pre>Building the jacobian matrix of the mapping from the reference
polyhedron to <span class="uid1">self</span>.</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code>tjac != 0</code></li>
    <li><code>tjac->nb_rows() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
    <li><code>tjac->nb_cols() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="build_tr_mapping_derivative"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void build_tr_mapping_derivative(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt_ref</span>,</tr>
  <tr><td /><td><code>GE_Matrix* <span class="uid1">tjac</span> ) const = 0</code></td></tr>
</table>
<pre>Building the transpose of the jacobian matrix of the mapping from the
reference polyhedron to <span class="uid1">self</span>.</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">tjac</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">tjac</span></span>->nb_rows() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">tjac</span></span>->nb_cols() == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="build_mapping_hessian"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void build_mapping_hessian(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* <span class="uid1">pt_ref</span>,</tr>
  <tr><td /><td><code><a href="doubleArray3D.html#" target="classFrame">doubleArray3D</a>* <span class="uid1">hessian</span>,</tr>
  <tr><td /><td><code>bool& <span class="uid1">nonzero_hessian</span> ) const</code></td></tr>
</table>
<br />
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt_ref</span></span>->nb_coordinates() == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">hessian</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">hessian</span></span>->index_bound( 0 ) == <a href="GE_Mpolyhedron.html#nb_space_dimensions" target="classFrame">nb_space_dimensions</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">hessian</span></span>->index_bound( 1 ) == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
    <li><code><span class="uid1"><span class="uid1">hessian</span></span>->index_bound( 2 ) == <a href="GE_Mpolyhedron.html#dimension" target="classFrame">dimension</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="print"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void print(</code></td><td><code>std::ostream& <span class="uid1">os</span>,</tr>
  <tr><td /><td><code>size_t <span class="uid1">indent_width</span> ) const</code></td></tr>
</table>
<pre>Write text to <span class="uid1">os</span> with <span class="uid1">indent_width</span> indentation.

</pre>
<br />
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

</body>
</html>
