<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html>
<head>
  <title>GE_QuadratureRule</title>
  <link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
</head>
<script>
  function asd()
  {
    parent.document.title="GE_QuadratureRule_PELICANS 17_03_2010 ";
  }
</script> 

<body onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<div id=navbar>
  <a name="navbar_top_firstrow"><!-- --></a>
  <div id=navbarapp>PELICANS 17_03_2010</div>
  <div id=navbarmenu>
    <a href="GEpack-tree.html"><span>Tree</span></a>
    <span class=selected>Class</span>
    <div id=navbarsub>
      <a href="index.html" target="_top">FRAMES :</a>
      <a href="GEpack-tree.html" target="_top">: NO FRAMES</a>
    </div>
  </div>
</div>
<!-- ========== END OF NAVBAR ========== -->

<br />
<div class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></div>
<br />


<!-- ====== START OF CLASS DATA ======== -->
<div id=classtitle>
  <span class=classpath>Geometry / Quadrature rules / </span><br />
  <span class=classname>Class  GE_QuadratureRule</span>
</div>

<br />

<div id=hierarchy>
<ul class=rootclass><li><a href="PEL_Object.html#" target="classFrame">PEL_Object</a></li>
  <ul class=self><li>GE_QuadratureRule</li>
</ul>
</div>

<!-- ========== DERIVED CLASSES ========== -->
<dl><dt><b>Direct Known Derived Classes:</b>
<dd><a href="GE_Cube_QR1.html#" target="classFrame">GE_Cube_QR1</a>, <a href="GE_Cube_QR3.html#" target="classFrame">GE_Cube_QR3</a>, <a href="GE_Cube_QR5.html#" target="classFrame">GE_Cube_QR5</a>, <a href="GE_Customized_QR.html#" target="classFrame">GE_Customized_QR</a>, <a href="GE_Mpoint_QR1.html#" target="classFrame">GE_Mpoint_QR1</a>, <a href="GE_Product_QR.html#" target="classFrame">GE_Product_QR</a>, <a href="GE_RefinedCube_QR.html#" target="classFrame">GE_RefinedCube_QR</a>, <a href="GE_RefinedSegment_QR.html#" target="classFrame">GE_RefinedSegment_QR</a>, <a href="GE_RefinedSquare_QR.html#" target="classFrame">GE_RefinedSquare_QR</a>, <a href="GE_RefinedTetrahedron_QR.html#" target="classFrame">GE_RefinedTetrahedron_QR</a>, <a href="GE_RefinedTriangle_QR.html#" target="classFrame">GE_RefinedTriangle_QR</a>, <a href="GE_Segment_QR1.html#" target="classFrame">GE_Segment_QR1</a>, <a href="GE_Segment_QR3.html#" target="classFrame">GE_Segment_QR3</a>, <a href="GE_Segment_QR5.html#" target="classFrame">GE_Segment_QR5</a>, <a href="GE_Segment_QR7.html#" target="classFrame">GE_Segment_QR7</a>, <a href="GE_Segment_QR9.html#" target="classFrame">GE_Segment_QR9</a>, <a href="GE_Square_QR1.html#" target="classFrame">GE_Square_QR1</a>, <a href="GE_Square_QR3.html#" target="classFrame">GE_Square_QR3</a>, <a href="GE_Square_QR5.html#" target="classFrame">GE_Square_QR5</a>, <a href="GE_Tetrahedron_QR1.html#" target="classFrame">GE_Tetrahedron_QR1</a>, <a href="GE_Tetrahedron_QR3.html#" target="classFrame">GE_Tetrahedron_QR3</a>, <a href="GE_Tetrahedron_QR5.html#" target="classFrame">GE_Tetrahedron_QR5</a>, <a href="GE_Triangle_QR1.html#" target="classFrame">GE_Triangle_QR1</a>, <a href="GE_Triangle_QR3.html#" target="classFrame">GE_Triangle_QR3</a>, <a href="GE_Triangle_QR5.html#" target="classFrame">GE_Triangle_QR5</a>, <a href="GE_Triangle_QR6.html#" target="classFrame">GE_Triangle_QR6</a>, <a href="GE_Triangle_QR7.html#" target="classFrame">GE_Triangle_QR7</a>, <a href="GE_Triangle_QR9.html#" target="classFrame">GE_Triangle_QR9</a></dd>
</dl>
<hr />
<pre>
Sets of points and sets of weights that define a method of numerical
integration, in the Gaussian sense, over a polyhedron.

Each quadrature rule can be characterized by its order. 
Integrals of any function over the polyhedron are approximated by the sum of 
function values at the quadrature points multiplied by the quadrature weights.
This method is exact for polynomials of degree up to the rule order.

Most rules are "instancied" once and for all by static method object ( unique 
instance ) but blank rules of type GE_Customized_QR can also been 
instancied.

IMPLEMENTATION :
   A register is maintained that maps the name of each concrete subclass
   (apart from <a href="GE_Customized_QR.html#" target="classFrame">GE_Customized_QR</a>) with the unique instance of 
   this subclass.

FRAMEWORK INSTANTIATION :
   1. Derive a concrete subclass, say <span class="uid1">MyRule</span>.
   2. Choose a name for <span class="uid1">MyRule</span>, say "MyRule".
   3. Declare all constructors private.
   4. Define the unique instance :
      4.1 Implement a default constuctor that initializes the 
          <a href="GE_QuadratureRule.html#" target="classFrame">GE_QuadratureRule</a> subobject by calling
     <a href="GE_QuadratureRule.html#GE_QuadratureRule" target="classFrame">GE_QuadratureRule( std::string, GE_ReferencePolyhedron const*, size_t )</a>
          with "MyRule" as a first argument.
          The default constructor should call in sequence
             <a href="GE_QuadratureRule.html#append_point" target="classFrame">append_point( GE_Point*, double )</a>
          for all integration points, and finally
             <a href="GE_QuadratureRule.html#set_sum_of_weights" target="classFrame">set_sum_of_weights( double )</a>
      4.2 Define and initialize a private static instance of <span class="uid1">MyRule</span> by
          calling the default private constructor :
            declaration :
               static MyRule* REGISTRATOR ;
            definition :
               MyRule* MyRule::REGISTRATOR = new MyRule() ;
   5. Implement a private destructor, that sets to zero REGISTRATOR
      defined above.
</pre>
<hr />
<a name="method_summary"></a>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Instance delivery and initialization</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#object" target="classFrame">static GE_QuadratureRule const* object( std::string a_name )</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Identification</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#name" target="classFrame">std::string const& name( void ) const</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Rule characteristics</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#reference_polyhedron" target="classFrame">GE_ReferencePolyhedron const* reference_polyhedron( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#order" target="classFrame">size_t order( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#nb_points" target="classFrame">size_t nb_points( void ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#point" target="classFrame">GE_Point const* point( size_t i ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#weight" target="classFrame">double weight( size_t i ) const</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#sum_of_weights" target="classFrame">double sum_of_weights( void ) const</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Input - Output</th><th class=protection>public</th></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#print" target="classFrame">virtual void print( std::ostream& os, size_t indent_width ) const</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Miscellaneous</th><th class=protection>protected</th></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#GE_QuadratureRule" target="classFrame"> GE_QuadratureRule( std::string a_name, GE_ReferencePolyhedron const* poly, size_t a_order )</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#GE_QuadratureRule_" target="classFrame"> GE_QuadratureRule( PEL_Object* a_owner, GE_ReferencePolyhedron const* poly, size_t a_order )</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#~GE_QuadratureRule" target="classFrame">virtual  ~GE_QuadratureRule( void )</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#append_point" target="classFrame">void append_point( GE_Point* pt, double pt_weight )</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#set_sum_of_weights" target="classFrame">void set_sum_of_weights( double sum )</a></td></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#clear_points" target="classFrame">void clear_points( void )</a></td></tr>
</table>

<!-- ========== NEW CATEGORY ========== -->
<table class=category cellpadding=2 cellspacing=0 rules=rows>
  <tr class=heading><th class=name>Preconditions, Postconditions, Invariant</th><th class=protection>protected</th></tr>
  <tr><td colspan="2"><a href="GE_QuadratureRule.html#invariant" target="classFrame">virtual bool invariant( void ) const</a></td></tr>
</table>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="object"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>static <a href="GE_QuadratureRule.html#" target="classFrame">GE_QuadratureRule</a> const* object(</code></td><td><code>std::string <span class="uid1">a_name</span> ) </code></td></tr>
</table>
<pre>a descendant instance</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code>!a_name.empty()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result-><a href="PEL_Object.html#is_under_ownership_of" target="classFrame">is_under_ownership_of</a>( <a href="PEL_Root.html#object" target="classFrame">PEL_Root::object</a>() )</code></li>
    <li><code>result-><a href="GE_QuadratureRule.html#name" target="classFrame">name</a>() == <span class="uid1"><span class="uid1">a_name</span></span></code></li>
    <li><code>result-><a href="GE_QuadratureRule.html#sum_of_weights" target="classFrame">sum_of_weights</a>() == result-><a href="GE_QuadratureRule.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>()->measure()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="name"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>std::string const& name(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>registration name of <span class="uid1">self</span></pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="reference_polyhedron"></a>
<div class=method>
<table class=prototype>
  <tr><td><code><a href="GE_ReferencePolyhedron.html#" target="classFrame">GE_ReferencePolyhedron</a> const* reference_polyhedron(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>polyhedron associated to <span class="uid1">self</span></pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="order"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>size_t order(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>if non-zero, maximum degree of the polynomial for which the method
of numerical integration defined by <span class="uid1">self</span> is exact</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="nb_points"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>size_t nb_points(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>number of integration points</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="point"></a>
<div class=method>
<table class=prototype>
  <tr><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a> const* point(</code></td><td><code>size_t <span class="uid1">i</span> ) const</code></td></tr>
</table>
<pre>geometrical location of the <span class="uid1">i</span>-th integration point</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">i</span></span> < <a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>()</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result != 0</code></li>
    <li><code>result-><a href="PEL_Object.html#owner" target="classFrame">owner</a>() == this</code></li>
    <li><code><a href="GE_QuadratureRule.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>()->contains( result )</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="weight"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>double weight(</code></td><td><code>size_t <span class="uid1">i</span> ) const</code></td></tr>
</table>
<pre>weight of the <span class="uid1">i</span>-th integration point</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">i</span></span> < <a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>()</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="sum_of_weights"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>double sum_of_weights(</code></td><td><code>void ) const</code></td></tr>
</table>
<pre>sum of the weight of all integration points</pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code>result > 0.</code></li>
    <li><code><a href="PEL.html#abs" target="classFrame">PEL::abs</a>( sum_weight_i - result ) < 1.E-8</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="print"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual void print(</code></td><td><code>std::ostream& <span class="uid1">os</span>,</tr>
  <tr><td /><td><code>size_t <span class="uid1">indent_width</span> ) const</code></td></tr>
</table>
<pre>Write text to <span class="uid1">os</span> with <span class="uid1">indent_width</span> indentation.

</pre>
<br />
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="GE_QuadratureRule"></a>
<div class=method>
<table class=prototype>
  <tr><td><code> GE_QuadratureRule(</code></td><td><code>std::string <span class="uid1">a_name</span>,</tr>
  <tr><td /><td><code><a href="GE_ReferencePolyhedron.html#" target="classFrame">GE_ReferencePolyhedron</a> const* <span class="uid1">poly</span>,</tr>
  <tr><td /><td><code>size_t <span class="uid1">a_order</span> ) </code></td></tr>
</table>
<pre>Initialize a <a href="GE_QuadratureRule.html#" target="classFrame">GE_QuadratureRule</a> subobject of a complete
object whose generating class is called <span class="uid1">a_name</span>,
whose order is <span class="uid1">a_order</span>, associated to the polyhedron <span class="uid1">poly</span>.</pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="GE_QuadratureRule_"></a>
<div class=method>
<table class=prototype>
  <tr><td><code> GE_QuadratureRule(</code></td><td><code><a href="PEL_Object.html#PEL_Object" target="classFrame">PEL_Object*</a> <span class="uid1">a_owner</span>,</tr>
  <tr><td /><td><code><a href="GE_ReferencePolyhedron.html#" target="classFrame">GE_ReferencePolyhedron</a> const* <span class="uid1">poly</span>,</tr>
  <tr><td /><td><code>size_t <span class="uid1">a_order</span> ) </code></td></tr>
</table>
<pre>exclusively for <a href="GE_Customized_QR.html#" target="classFrame">GE_Customized_QR</a></pre>
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="~GE_QuadratureRule"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual~GE_QuadratureRule(</code></td><td><code>void ) </code></td></tr>
</table>
<br />
<br />
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="append_point"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>void append_point(</code></td><td><code><a href="GE_Point.html#" target="classFrame">GE_Point</a>* <span class="uid1">pt</span>,</tr>
  <tr><td /><td><code> double <span class="uid1">pt_weight</span> ) </code></td></tr>
</table>
<pre>Make <span class="uid1">pt</span> an element of the set of integration points with an
associated quadrature weight <span class="uid1">pt_weight</span> (to be called in the
default constructor of concrete descendants).
On exit, <span class="uid1">self</span> still refers to the object identified by <span class="uid1">pt</span>.</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">pt</span></span> != 0</code></li>
    <li><code><span class="uid1"><span class="uid1">pt</span></span>-><a href="PEL_Object.html#owner" target="classFrame">owner</a>() == this</code></li>
    <li><code><span class="uid1"><span class="uid1">pt</span></span>->nb_coordinates() == <a href="GE_QuadratureRule.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>()->dimension()</code></li>
    <li><code><a href="GE_QuadratureRule.html#reference_polyhedron" target="classFrame">reference_polyhedron</a>()->contains( <span class="uid1"><span class="uid1">pt</span></span> )</code></li>
    <li><code>FORALL( i = 0, i < <a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>(), ++i )<br />
&nbsp;!<span class="uid1"><span class="uid1">pt</span></span>-><a href="PEL_Object.html#is_equal" target="classFrame">is_equal</a>( <a href="GE_QuadratureRule.html#point" target="classFrame">point</a>( i ) )</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code><a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>() == OLD( <a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a> ) + 1</code></li>
    <li><code><a href="GE_QuadratureRule.html#point" target="classFrame">point</a>( <a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>() - 1 ) == <span class="uid1"><span class="uid1">pt</span></span></code></li>
    <li><code><a href="GE_QuadratureRule.html#weight" target="classFrame">weight</a>( <a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>() - 1 ) == <span class="uid1"><span class="uid1">pt_weight</span></span></code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="set_sum_of_weights"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>void set_sum_of_weights(</code></td><td><code>double <span class="uid1">sum</span> ) </code></td></tr>
</table>
<pre>Set the value of the sum of the weight of all integration points
at <span class="uid1">sum</span> (that value will be subsequently returned
by <a href="GE_QuadratureRule.html#sum_of_weights" target="classFrame">sum_of_weights</a>, which avoids useless calculations).</pre>
<br />
<div class=conditions>
  <span class=precondition>Precondition</span>
  <ul>
    <li><code><span class="uid1"><span class="uid1">sum</span></span> > 0.</code></li>
    <li><code><a href="PEL.html#abs" target="classFrame">PEL::abs</a>( sum_weight_i - <span class="uid1"><span class="uid1">sum</span></span> ) < 1.E-8</code></li>
  </ul>
<br />
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code><a href="GE_QuadratureRule.html#sum_of_weights" target="classFrame">sum_of_weights</a>() == <span class="uid1"><span class="uid1">sum</span></span></code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="clear_points"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>void clear_points(</code></td><td><code>void ) </code></td></tr>
</table>
<pre>Clear all points.</pre>
<br />
<div class=conditions>
  <span class=postcondition>Postcondition</span>
  <ul>
    <li><code><a href="GE_QuadratureRule.html#nb_points" target="classFrame">nb_points</a>() == 0</code></li>
  </ul>
</div>
<table class=footer>
<tr>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

<!-- ========== NEW METHOD ========== -->
<hr />
<a name="invariant"></a>
<div class=method>
<table class=prototype>
  <tr><td><code>virtual bool invariant(</code></td><td><code>void ) const</code></td></tr>
</table>
<br />
<br />
<table class=footer>
<tr>
  <td class=overrides> Overridden from <a href="PEL_Object.html#" target="classFrame">PEL_Object</a></td>
  <td class=link2anchor>SUMMARY :: <a href="#method_summary">METHOD</a></td></tr>
</table>
</div>

</body>
</html>
